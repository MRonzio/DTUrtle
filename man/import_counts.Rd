% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/dtu_analysis.R
\name{import_counts}
\alias{import_counts}
\title{Import quantification results}
\usage{
import_counts(files, type, ...)
}
\arguments{
\item{files}{Vector of files to be imported. Optionally can be named to keep the samples names.}

\item{type}{Type of the quantification data. All tools supported by \code{\link[tximport:tximport]{tximport}} can be selected, additionally to the newly implemented \code{bustools} support for single-cell data. If you have single-cell data, the use of \code{alevin} or \code{bustools} is proposed.
\itemize{
\item \code{'salmon'}
\item \code{'alevin'}
\item \code{'kallisto'}
\item \code{'bustools'}
\item \code{'rsem'}
\item \code{'stringtie'}
\item \code{'sailfish'}
\item \code{'none'}
}}

\item{...}{
  Arguments passed on to \code{\link[tximport:tximport]{tximport::tximport}}
  \describe{
    \item{\code{txIn}}{logical, whether the incoming files are transcript level (default TRUE)}
    \item{\code{txOut}}{logical, whether the function should just output
transcript-level (default FALSE)}
    \item{\code{countsFromAbundance}}{character, either "no" (default), "scaledTPM",
"lengthScaledTPM", or "dtuScaledTPM".
Whether to generate estimated counts using abundance estimates:
\itemize{
  \item scaled up to library size (scaledTPM),
  \item scaled using the average transcript length over samples
        and then the library size (lengthScaledTPM), or
  \item scaled using the median transcript length among isoforms of a gene,
        and then the library size (dtuScaledTPM). 
}
dtuScaledTPM is designed for DTU analysis in combination with \code{txOut=TRUE},
and it requires specifing a \code{tx2gene} data.frame.
dtuScaledTPM works such that within a gene, values from all samples and
all transcripts get scaled by the same fixed median transcript length.
If using scaledTPM, lengthScaledTPM, or geneLengthScaledTPM, 
the counts are no longer correlated across samples with transcript length,
and so the length offset matrix should not be used.}
    \item{\code{tx2gene}}{a two-column data.frame linking transcript id (column 1)
to gene id (column 2).
the column names are not relevant, but this column order must be used. 
this argument is required for gene-level summarization, and the tximport
vignette describes how to construct this data.frame (see Details below).
An automated solution to avoid having to create \code{tx2gene} if
one has quantified with Salmon or alevin with human or mouse transcriptomes
is to use the \code{tximeta} function from the tximeta Bioconductor package.}
    \item{\code{varReduce}}{whether to reduce per-sample inferential replicates
information into a matrix of sample variances \code{variance} (default FALSE).
alevin computes inferential variance by default for bootstrap
inferential replicates, so this argument is ignored/not necessary}
    \item{\code{dropInfReps}}{whether to skip reading in inferential replicates
(default FALSE). For alevin, \code{tximport} will still read in the
inferential variance matrix if it exists}
    \item{\code{infRepStat}}{a function to re-compute counts and abundances from the
inferential replicates, e.g. \code{matrixStats::rowMedians} to re-compute counts 
as the median of the inferential replicates. The order of operations is:
first counts are re-computed, then abundances are re-computed.
Following this, if \code{countsFromAbundance} is not "no",
\code{tximport} will again re-compute counts from the re-computed abundances.
\code{infRepStat} should operate on rows of a matrix. (default is NULL)}
    \item{\code{ignoreTxVersion}}{logical, whether to split the tx id on the '.' character
to remove version information to facilitate matching with the tx id in \code{tx2gene}
(default FALSE)}
    \item{\code{ignoreAfterBar}}{logical, whether to split the tx id on the '|' character
to facilitate matching with the tx id in \code{tx2gene} (default FALSE)}
    \item{\code{geneIdCol}}{name of column with gene id. if missing, the \code{tx2gene}
argument can be used}
    \item{\code{txIdCol}}{name of column with tx id}
    \item{\code{abundanceCol}}{name of column with abundances (e.g. TPM or FPKM)}
    \item{\code{countsCol}}{name of column with estimated counts}
    \item{\code{lengthCol}}{name of column with feature length information}
    \item{\code{importer}}{a function used to read in the files}
    \item{\code{existenceOptional}}{logical, should tximport not check if files exist before attempting
import (default FALSE, meaning files must exist according to \code{file.exists})}
    \item{\code{sparse}}{logical, whether to try to import data sparsely (default is FALSE).
Initial implementation for \code{txOut=TRUE}, \code{countsFromAbundance="no"}
or \code{"scaledTPM"}, no inferential replicates. Only counts matrix
is returned (and abundance matrix if using \code{"scaledTPM"})}
    \item{\code{sparseThreshold}}{the minimum threshold for including a count as a
non-zero count during sparse import (default is 1)}
    \item{\code{readLength}}{numeric, the read length used to calculate counts from
StringTie's output of coverage. Default value (from StringTie) is 75.
The formula used to calculate counts is:
\code{cov * transcript length / read length}}
    \item{\code{alevinArgs}}{named list, with logical elements \code{filterBarcodes},
\code{tierImport}, \code{forceSlow}. See Details for definitions.}
  }}
}
\value{
\itemize{
\item For bulk data: A combined count matrix for all specified samples.
\item For single-cell data: A list of count matrices per sample. Should be combined and optionally added to a Seurat object with \code{\link[=combine_to_matrix]{combine_to_matrix()}}.
}
}
\description{
Import the quantification results of many RNA-seq quantifiers, including \code{alevin} and \code{bustools} for single-cell data.
Most likely the first step in your DTUrtle analysis.
}
\details{
Can perform multiple scaling schemes, defaults to scaling schemes appropriate for DTU analysis. For bulk data it is recommended to additionally specify a \code{tx2gene} data frame as parameter.
This data frame must be a a two-column data frame linking transcript id (column 1) to gene id/name (column 2). This data frame is used to apply a DTU specific scaling scheme (dtuScaledTPM).
Please see \code{\link[=import_gtf]{import_gtf()}}, \code{\link[=move_columns_to_front]{move_columns_to_front()}} and \code{\link[=one_to_one_mapping]{one_to_one_mapping()}} to help with tx2gene creation.
See also \code{\link[=combine_to_matrix]{combine_to_matrix()}}, when output is a list of single-cell runs.
}
\seealso{
Please see \code{\link[=import_gtf]{import_gtf()}}, \code{\link[=move_columns_to_front]{move_columns_to_front()}} and \code{\link[=one_to_one_mapping]{one_to_one_mapping()}} to help with tx2gene creation. See also \code{\link[=combine_to_matrix]{combine_to_matrix()}}, when output is a list of single-cell runs.

Other DTUrtle DTU: 
\code{\link{combine_to_matrix}()},
\code{\link{posthoc_and_stager}()},
\code{\link{priming_bias_detection_probability}()},
\code{\link{run_drimseq}()}
}
\concept{DTUrtle DTU}
