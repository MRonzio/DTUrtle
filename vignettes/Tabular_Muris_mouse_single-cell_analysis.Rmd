---
title: "Analysis of Tabular Muris mouse single-cell RNA-seq data"
author: "Tobias Tekath"
date: "`r Sys.Date()`"
description: "Exemplified analysis of mouse single-cell RNA-seq data (10X Chromium)."
output: 
  rmarkdown::html_vignette:
    df_print: paged
    toc: true
    toc_depth: 3
vignette: >
  %\VignetteIndexEntry{Analysis of Tabular Muris mouse single-cell RNA-seq data}
  %\VignetteBuilder{knitr}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
root_dir <- "/data/tabula_muris/dtu_results"
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  cache = FALSE,
  eval = dir.exists(root_dir)
)
if(dir.exists(root_dir)){
  knitr::opts_knit$set(root.dir = root_dir)
  #remove previous results
  unlink(paste0(root_dir,"/*"),recursive=TRUE)
}
start_time <- Sys.time()
```


This vignette exemplifies the analysis of **single-cell RNA-seq data with DTUrtle**. The data used in this vignette is publicly available as *Bioproject PRJNA432002* and the used *FASTQ*-files can be downloaded from [here](https://www.ebi.ac.uk/ena/browser/view/PRJNA432002). The corresponding publication can be found [here](https://doi.org/10.1038/s41586-018-0590-4).

---

The following code shows an example of an DTUrtle workflow. Assume we have performed the pre-processing as described [here](https://tobitekath.github.io/DTUrtle/articles/Tabular_Muris_mouse_single-cell_preprocess.html) and the R working directory is a newly created folder called `dtu_results`.

---

## Setup

Load the DTUrtle package and set the BiocParallel parameter. It is recommended to perform computations in parallel, if possible. 

```{r message=TRUE, warning=TRUE}
library(DTUrtle)
#use up to 10 cores for computation
biocpar <- BiocParallel::MulticoreParam(10)
```

---

## Import and format data

We want to start by reading in our quantification counts, as well as a file specifying which transcript ID or name belongs to which gene ID or name.

### Importing and processing GTF annotation (tx2gene)

To get this transcript to gene (`tx2gene`) mapping, we will utilize the already present Gencode annotation file `gencode.vM24.annotation.gtf`. The `import_gtf()` function utilizes the a `rtracklayer` package and returns a transcript-level filtered version of the available data.


```{r}
tx2gene <- import_gtf(gtf_file = "../gencode.vM24.annotation.gtf")
```

```{r}
head(tx2gene, n=3)
```



There are a lot of columns present in the data frame, but at the moment we are mainly interested in the columns `gene_id`, `gene_name`, `transcript_id` and `transcript_name`. 

---

As we want to use gene and transcript names as the main identifiers in our analysis (so we can directly say: Gene x is differential), we should ensure that each gene / transcript name maps only to a single gene / transcript id.

For this we can use the DTUrtle function `one_to_one_mapping()`, which checks if there are identifiers, which relate to the same name. If this is the case, the names (**not** the identifiers) are slightly altered by appending a number. If *id_x* and *id_y* both have the name *ABC*, the *id_y* name is altered to *ABC_2* by default.  

```{r}
tx2gene$gene_name <- one_to_one_mapping(name = tx2gene$gene_name, id = tx2gene$gene_id)
tx2gene$transcript_name <- one_to_one_mapping(name = tx2gene$transcript_name, id = tx2gene$transcript_id)
```

We see that it was a good idea to ensure the one to one mapping, as many doublets have been corrected.

---

For the `run_drimseq()` `tx2gene` parameter, we need a data frame, where the first column specifies the transcript identifiers and the second column specifying the corresponding gene names. Rather than subsetting the data frame, a column reordering is proposed, so that additional data can still be used in further steps. DTUrtle makes sure to carry over additional data columns in the analysis steps. To reorder the columns of our tx2gene data frame, we can utilize the `move_columns_to_front()` functionality.

```{r}
tx2gene <- move_columns_to_front(df = tx2gene, columns = c("transcript_name", "gene_name"))
```

```{r}
head(tx2gene, n=5)
```


This concludes the tx2gene formatting.

---

### Reading in quantification data

The read-in of the quantification counts can be achieved with `import_counts()`, which uses the `tximport` package in the background. This function is able to parse the output of many different quantification tools. Advanced users might be able to tune parameters to parse arbitrary output files from currently not supported tools.

In the pre-processing vignette we quantified the counts with `Alevin`. The folder structure of the quantification results folder looks like this:

```{r}
list.files("../alevin/")
```

We will create a named files vector, pointing to the `quants_mat.gz` file for each sample. The names help to differentiate the samples later on.

```{r}
files <- Sys.glob("../alevin/10X_P7_*/alevin/quants_mat.gz")
names(files) <- basename(gsub("/alevin/quants_mat.gz", "", files))
```

The files object looks like this:
```{r, echo=FALSE}
files
```

The actual import will be performed with `import_counts()`.

```{r}
cts_list <- import_counts(files = files, type = "alevin")
```

The `cts_list` object is a named list, with a sparse Matrix per sample. In single-cell data, each sample normally consists of many different cells with an unique cell barcode. These cell barcodes might overlap between samples though. For this reason, many single-cell workflow use a cell barcode extension, uniquely assigning each cell to a sample. This can also be done in DTUrtle with `combine_to_matrix()`, which is only applicable if you are analyzing single-cell data. 

This function will make sure that there are no duplicated barcodes between you samples, before merging the matrices together. If there are duplicated barcodes, a cell extension is added. Additionally, all not expressed features are removed to reduce the size of the data.

To have matching cell names with the sample annotation we add [in the next step](#sample-metadata), we set the cell extensions explicitly and prepend them.

```{r}
cts <- combine_to_matrix(tx_list = cts_list, cell_extensions = c("10X_P7_12", "10X_P7_13"), cell_extension_side = "prepend")
```

Apparently there were some duplicated cell barcodes between our samples, so a cell barcode extensions are useful either way.

```{r}
dim(cts)
```

There are ~91k features left for 8318 cells.

---

### Sample metadata

Finally, we need a sample metadata data frame, specifying which sample belongs to which comparison group. This table is also convenient to store and carry over additional metadata.

For single-cell data, this is not a sample metadata data frame, but a cell metadata data frame. We have to specify the information on cell level, with the barcodes as identifiers.

As we want to use the cell type assignments from the Tabula Muris project, we download the `Robj` file containing the annotation. The Tabula Muris Data has been deposited at [Figshare](https://figshare.com/projects/Tabula_Muris_Transcriptomic_characterization_of_20_organs_and_tissues_from_Mus_musculus_at_single_cell_resolution/27733)

We can perform the download with the following *bash* code:

```{bash eval=FALSE}
wget -O ../droplet_Mammary_Gland_seurat_tiss.Robj https://ndownloader.figshare.com/files/13089629
```

The `meta.data` data frame of this object contains the wanted annotation.

```{r}
library(Seurat)
load("../droplet_Mammary_Gland_seurat_tiss.Robj", verbose=TRUE)

tabula_muris_metadata <- tiss@meta.data
dim(tabula_muris_metadata)
```

```{r}
head(tabula_muris_metadata, n=5)
```
 
As we have only cell type information available for cells analyzed in Tabula Muris, we subset our data set to the matching cells.

```{r}
cts <- cts[,rownames(tabula_muris_metadata)]
dim(cts)
```

All 4481 cells from Tabula Muris have been recovered. The `tabula_muris_metadata` data frame can be used as our meta data table.


**For an example workflow utilizing the Seurat object directly, please see [Workflow with Seurat object](#workflow-with-seurat-object)**

```{r, include=FALSE}
### save counts and pd for comparison with Wuidart et al. data set.
saveRDS(cts, "../../Smart-seq2/tabula_muris_cts.RDS")
saveRDS(tabula_muris_metadata, "../../Smart-seq2/tabula_muris_pd.RDS")
```


---

### (optional) Estimate influence of priming-bias

As the 10X Chromium 3' protocol preferentially generates reads of the 3'-end of an mRNA, DTU effects of some specific transcripts might not be detectable.
DTUrtle offers a novel scoring scheme, called "detection probability", to assess which transcripts might be prone to be impaired by such a bias. This score can be computed with the DTUrtle function `priming_bias_detection_probability()`.

The score calculation can be summarized like this: For each gene, a reference transcript is chosen (based on the expression data, selecting the major proportionally expressed transcript as reference). Each other transcript of a gene is now compared to this reference transcript, calculating where the first detectable exon-level difference occurs between the transcript entities - and at what relative coordinate this difference is located (looking from the priming enriched end). Based on this information, a `detection probability` is calculated, with 1 indicating no influence of the prime-biased reads on the detection ability and 0 indicating a very heavy influence. Thus, DTU effects for transcripts with a low score would be expected less likely to be detectable with the given data. 

We can add this score information to an already existing table, like the tx2gene table (`add_to_table = tx2gene`). As we need exon-level information for the calculation, we should provide an unfiltered GTF GRanges or data frame object - or alternatively a file path.

```{r}
unfilt_gtf <- import_gtf("../gencode.vM24.annotation.gtf", feature_type = NULL, out_df = FALSE)
#set priming_enrichment to '3', as we expect reads enriched towards the 3' end of the mRNA.
tx2gene <- priming_bias_detection_probability(counts = cts, tx2gene = tx2gene, gtf = unfilt_gtf, one_to_one = TRUE,
                                              priming_enrichment = "3", add_to_table = tx2gene, BPPARAM = biocpar)
```

The newly added columns are `detection_probability` and `used_as_ref`:

```{r}
head(tx2gene[,c("transcript_name", "gene_name", "detection_probability", "used_as_ref")])
```

We can calculate, that a potential 3'-bias would not influence the majority of annotated transcripts, relevant for the DTU analysis:
```{r}
#only genes with at least two transcript isoforms are relevant for DTU analysis
dtu_relevant_genes <- unique(tx2gene$gene_name[duplicated(tx2gene$gene_name)])
summary(tx2gene$detection_probability[tx2gene$gene_name %in% dtu_relevant_genes])
```


---

## DTU analysis

We have prepared all necessary data to perform the differentially transcript usage (DTU) analysis. DTUrtle only needs two simple commands to perform it. Please be aware that these steps are the most compute intensive and, depending on your data, might take some time to complete. It is recommended to parallelize the computations with the `BBPARAM` parameter, if applicable.

First, we want to set-up and perform the statistical analysis with DRIMSeq, a DTU specialized statistical framework utilizing a Dirichlet-multinomial model. This can be done with the `run_drimseq()` command. We use the previously imported data as parameters, specifying which column in the cell metadata data frame contains ids and which the group information we want. We should also specify which of the groups should be compared (if there are more than two) and in which order. The order given in the `cond_levels` parameter also specifies the comparison formula.

In this example we choose two specific cell types (from the column `cell_ontology_class`) and do not specify the id column, as rownames are chosen by default.

> <div class="alert alert-info">
>
> <strong>Note:</strong>  By default `run_drimseq()` converts sparse count matrix to a dense format for statistical computations (`force_dense=TRUE`). While this increases memory usage, it currently also reduces the run time.
The computations can be performed keeping the sparse counts by setting `force_dense=FALSE`.
>
> </div>


```{r}
dturtle <- run_drimseq(counts = cts, tx2gene = tx2gene, pd=tabula_muris_metadata,
                    cond_col = "cell_ontology_class", 
                    cond_levels = c("T cell", "luminal epithelial cell of mammary gland"),
                    filtering_strategy = "sc", BPPARAM = biocpar)
```

As in all statistical procedures, it is of favor to perform as few tests as possible but as much tests as necessary, to maintain a high statistical power. This is achieved by filtering the data to remove inherently uninteresting items, for example very lowly expressed genes or features. DTUrtle includes a powerful and customizable filtering functionality for this task, which is an optimized version of the `dmFilter()` function of the DRIMSeq package. 

Above we used a predefined filtering strategy for single-cell data, requiring that features contribute at least 5% of the total expression in at least 5% of the cells of the smallest group. Additionally, all genes are filtered, which only have a single transcript left, as they can not be analyzed in DTU analysis. The filtering options can be extended or altered by the user.

```{r}
dturtle$used_filtering_options
```

The resulting `dturtle` object will be used as our main results object, storing all necessary and interesting data of the analysis. It is a simple and easy-accessible list, which can be easily extended / altered by the user. By default three different meta data tables are generated:
 - `meta_table_gene`: Contains gene level meta data.
 - `meta_table_tx`: Contains transcript level meta data.
 - `meta_table_sample`: Contains sample level meta data (as the created `pd` data frame)
 
These meta data tables are used in for visualization purposes and can be extended by the user.


```{r}
head(dturtle$meta_table_gene, n=5)
```

This table shows the single genes, together with their total expressed-in ratio ("exp_in"), the specific expressed-in ratios in the specific comparison groups, as well with other information from the provided GTF-file.

---

As proposed in [Love et al. (2018)](https://doi.org/10.12688/f1000research.15398.3), we will use a two-stage statistical testing procedure together with a post-hoc filtering on the standard deviations in proportions (`posthoc_and_stager()`). We will use *stageR* to determine genes, that show a overall significant change in transcript proportions. For these significant genes, we will try to pinpoint specific transcripts, which significantly drive this overall change. As a result, we will have a list of `significant genes` (genes showing the overall change) and a list of `significant transcripts` (one or more transcripts of the `significant genes`). Please note, that not every `significant gene` does have one or more `significant transcripts`. It is not always possible to attribute the overall change in proportions to single transcripts. These two list of significant items are computed and corrected against a **overall false discovery rate (OFDR)**.

Additionally, we will apply a post-hoc filtering scheme to improve the targeted OFDR control level. The filtering strategy will discard transcripts, which standard deviation of the proportion per cell/sample is below the specified threshold. For example by setting `posthoc=0.1`, we will exclude all transcripts, which proportional expression (in regard to the total gene expression) deviates by less than 0.1 between cells.
This filtering step should mostly exclude 'uninteresting' transcripts, which would not have been called as significant either way. 

```{r}
dturtle <- posthoc_and_stager(dturtle = dturtle, ofdr = 0.05, posthoc = 0.1)
```

The `dturtle` object now contains additional elements, including the lists of `significant genes` and `significant transcripts`.

```{r}
head(dturtle$sig_gene)
head(dturtle$sig_tx)
```

---

## (optional) DGE analysis

Alongside a DTU analysis, a DGE analysis might be of interest for your research question. DTUrtle offers a basic DGE calling workflow for bulk and single-cell RNA-seq data via DESeq2.

To utilize this workflow, we should re-scale our imported counts. The transcript-level count matrix has been scaled for the DTU analysis, but for a DGE analysis un-normalized counts should be used (as DESeq2 normalizes internally). We can simply re-import the count data, by providing the already defined `files` object to the DGE analysis specific function `import_dge_counts()`. This function will make sure that the counts are imported but not scaled and also summarizes to gene-level.

Our files object looks like this:

```{r}
head(files)
```

We re-import the files and use `combine_to_matrix()` to create one big matrix (as we did for the DTU analysis):

```{r}
cts_dge <- import_dge_counts(files, type="alevin", tx2gene=tx2gene)
cts_dge <- combine_to_matrix(tx_list = cts_dge, cell_extensions = c("10X_P7_12", "10X_P7_13"), cell_extension_side = "prepend")
```

With this data, we can perform the DGE analysis with DESeq2 with the DTUrtle function `run_deseq2()`. DESeq2 is one of the gold-standard tools for DGE calling in bulk RNA-seq data and showed very good performance for single-cell data in multiple benchmarks. The DESeq2 vignette recommends adjusting some parameters for DGE analysis of single-cell data - DTUrtle incorporates these recommendations and adjusts the specific parameters based on the provided `dge_calling_strategy`.

After the DESeq2 DGE analysis, the estimated log2 fold changes are shrunken (preferably with `apeglm`) - to provide a secondary ranking variable beside the statistical significance. If a shrinkage with `apeglm` is performed, `run_deseq2()` defaults to also compute s-values rather than adjusted p-values. The underlying hypothesis for s-values and (standard) p-values differs slightly, with s-values hypothesis being presumably preferential in a real biological context. Far more information about all these topics can be found in the excellent [DESeq2 vignette](https://bioconductor.org/packages/release/bioc/vignettes/DESeq2/inst/doc/DESeq2.html) and the associated publications.

`run_deseq2()` will tell the user, if one or more advised packages are missing. It is strongly advised to follow these recommendations.

```{r}
dturtle$dge_analysis <- run_deseq2(counts = cts_dge, pd = tabula_muris_metadata, cond_col = "cell_ontology_class", 
                                   cond_levels = c("T cell", "luminal epithelial cell of mammary gland"), lfc_threshold = 1,
                                   sig_threshold = 0.01, dge_calling_strategy = "sc", BPPARAM = biocpar)
```

We provided a log2 fold change threshold of 1 (on log2 scale), thus preferring an effect size of 2x or more.
The output of `run_deseq2()` is a list, containing various elements (see `run_deseq2()`'s description). This result list can easily added to an existing DTUrtle object, as shown above.

We can now identify genes which show both a DGE and DTU signal:

```{r}
dtu_dge_genes <- intersect(dturtle$sig_gene, dturtle$dge_analysis$results_sig$gene)
length(dtu_dge_genes)
```

---

## Result aggregation and visualization

The `DTUrtle` package contains multiple visualization options, enabling an in-depth inspection.

### DTU table creation

We will start by aggregating the analysis results to a data frame with `create_dtu_table()`. This function is highly flexible and allows aggregation of gene or transcript level metadata in various ways. By default some useful information are included in the *dtu table*, in this example we further specify to include the `seqnames` column of the gene level metadata (which contains chromosome information) as well as the maximal *expressed in* ratio per cell type from the transcript level metadata ("expressed in" specifies the ratio of cells, were the expression of the gene / transcript is > 0). Furthermore we add the a column with the absolute difference between the *expressed in* ratios.

```{r}
dturtle <- create_dtu_table(dturtle = dturtle, add_gene_metadata = list("chromosome"="seqnames"), 
                               add_tx_metadata = list("max_tx_expr_in_T_cell" = c("exp_in_T cell", max),
                                                      "max_tx_expr_in_luminal_epithelial_cell_of_mammary_gland" = 
                                                        c("exp_in_luminal epithelial cell of mammary gland", max)))

# add absolute difference between "expressed in" columns.
dturtle$dtu_table$abs_diff_expr_in <- abs(dturtle$dtu_table$max_tx_expr_in_T_cell-dturtle$dtu_table$max_tx_expr_in_luminal_epithelial_cell_of_mammary_gland)
```


```{r}
head(dturtle$dtu_table, n=5)
```


This table is our basis for creating an **interactive HTML-table** of the results. 

The column definitions are as follows:

* "gene_ID": Gene name or identifier used for the analysis.
* "gene_qvalue": Multiple testing corrected p-value (a.k.a. q-value) comparing all transcripts together between the two groups ("gene level").
* "minimal_tx_qvalue": The minimal multiple testing corrected p-value from comparing all transcripts  individually between the two groups ("transcript level"). I.e. the q-value of the most significant transcript.
* "number_tx": The number of analyzed transcripts for the specific gene.
* "number_significant_tx": The number of significant transcripts from the 'transcript level' analysis.
* "max(T cell-luminal epithelial cell of mammary gland)": Maximal proportional difference between the two groups (T cell vs luminal epithelial cell of mammary gland). E.g. one transcript of 'Pde4d' is ~82% more expressed in 'luminal epithelial cell of mammary gland' cells compared to 'T cell' cells.
* "chromosome": the chromosome the gene resides on.

Please note, that the columns and their meaning can easily be altered and redefined by the user.

---

### Proportion barplot

As a first visualization option we will create a barplot of the proportions of each transcript per sample. We can use the function `plot_proportion_barplot()` for this task, which also adds the mean proportion fit per subgroup to the plot (by default as a red line).

As an example, we will create the plot for the gene *Lcn2*, which is one of the significant genes found in the analysis. We will optionally provide the gene_id for *Lcn2*, which is stored in the column `gene_id.1` of `dturtle$meta_table_gene`.


```{r, fig.height=6, fig.width=8, fig.align = "center", out.width="80%"}
temp <- plot_proportion_barplot(dturtle = dturtle, genes = "Lcn2", meta_gene_id = "gene_id.1")
temp$Lcn2
```

We see, that most of the proportional differences for *Lcn2* are driven by 2 of the 3 transcripts (*Lcn2-201* and *Lcn2-203*). These transcripts are also the significant transcripts found in the analysis (as they are marked in red). Notably 3 other transcripts of *Lcn2* have been removed by the filtering thresholds in `run_drimseq()`.  *Lcn2-201* is proportionally overexpressed in `luminal epithelial cell of mammary gland` cells, in contrast to *Lcn2-203* which is proportionally overexpressed in `T cell` cells. We additionally see, that the overall expression level of *Lcn2* is way higher in `luminal epithelial cell of mammary gland` than in `T cell`.

For the interactive HTML-table we would need to save the images to disk (in the to-be-created sub folder "images" of the current working directory). There is also a convenience option, to directly add the file paths to the `dtu_table`. As multiple plots are created, we can provide a `BiocParallel` object to speed up the creation. If no specific genes are provided, all significant genes will be plotted.

```{r}
dturtle <- plot_proportion_barplot(dturtle = dturtle, 
                                   meta_gene_id = "gene_id.1", 
                                   savepath = "images", 
                                   add_to_table = "barplot",
                                   BPPARAM = biocpar)
```

```{r}
head(dturtle$dtu_table$barplot)
head(list.files("./images/"))
```


---

### Proportion heatmap

A different visualization option is a heatmap, where additional meta data can be displayed alongside the transcript proportions (`plot_proportion_pheatmap()`). This visualization uses the `pheatmap` package, the user can specify any of the available parameters to customize the results.


```{r, fig.height=6, fig.width=8, fig.align = "center", out.width="80%"}
temp <- plot_proportion_pheatmap(dturtle = dturtle, genes = "Lcn2", 
                                 sample_meta_table_columns = c("sample_id","condition"),
                                 include_expression = TRUE, treeheight_col=20)
temp$Lcn2
```

By default, row and column annotations are added. This plot helps to examine the transcript composition of groups of cells. We see, the vast majority of `luminal epithelial cell of mammary gland` cells are exclusively expressing *Lcn2-201*. The *Lcn2* expressing cells of the `T cell` cells are mostly split-expressing *Lcn2-201* and *Lcn2-203*. The significant transcripts are indicated by the row annotation on the left side of the heatmap.

Again, we can save the plots to disk and add them to the `dtu_table`:


```{r}
dturtle <- plot_proportion_pheatmap(dturtle = dturtle,
                                    include_expression = TRUE,
                                    treeheight_col=20,
                                    sample_meta_table_columns = c("sample_id","condition"),
                                    savepath = "images", 
                                    add_to_table = "pheatmap",
                                    BPPARAM = biocpar)
```

```{r}
head(dturtle$dtu_table$pheatmap)
head(list.files("./images/"))
```

---

### Transcript overview

Until now, we looked at the different transcripts as abstract entities. Alongside proportional differences, the actual difference in the exon-intron structure of transcripts is of great importance for many research questions. This structure can be visualized with the `plot_transcripts_view()` functionality of *DTUrtle*.

This visualization is based on the *Gviz* package and needs a path to a *GTF* file (or a read-in object). In [Import and format data](#import-and-format-data) we already imported a GTF file. This was subset to transcript-level (via the `import_gtf()` function), thus this is **not** sufficient for the visualization. We can reuse the actual *GTF* file though, which should in general match with the one used for the `tx2gene` data frame. 

As we have ensured the one_to_one mapping in [Import and format data](#import-and-format-data) and potentially renamed some genes, we should specify the `one_to_one` parameter in this call. 

```{r, fig.height=6, fig.width=8, fig.align = "center", out.width="80%"}
plot_transcripts_view(dturtle = dturtle, 
                              genes = "Lcn2", 
                              gtf = "../gencode.vM24.annotation.gtf", 
                              genome = 'mm10',
                              one_to_one = TRUE)
```



This visualization shows the structure of the transcripts of *Lcn2*. Our two significant transcripts (*Lcn2-201* and *Lcn2-203*) are quite different, with alternative end points as well as some retained intron sequences in *Lcn2-203*. The arrows on the right side indicate the mean fitted proportional change in the comparison groups, thus showing a under-expression of *Lcn2-201* in `T cell` compared to `luminal epithelial cell of mammary gland`.

The areas between exons indicate intron sequences, which have been compressed in this representation to highlight the exon structure. Only consensus introns are compressed to a defined minimal size. This can be turned off with `reduce_introns=FALSE` or alternatively reduced introns can be highlighted by setting a colorful `reduce_introns_fill`.

Analogous as before, we can save plots to disk and add them to the `dtu_table`:


```{r}
dturtle <- plot_transcripts_view(dturtle = dturtle, 
                                 gtf = "../gencode.vM24.annotation.gtf", 
                                 genome = 'mm10', 
                                 one_to_one = TRUE,
                                 savepath = "images", 
                                 add_to_table = "transcript_view",
                                 BPPARAM = biocpar)
```

```{r}
head(dturtle$dtu_table$transcript_view)
head(list.files("./images/"))
```

---

### Dimensional reduction

Most RNA-seq analysis perform some kind of dimensional reduction method to visualize the samples in two (or three) dimensions. This is most useful for single-cell data sets or bulk experiments with a very high number of samples.

For these kind of experiments, *DTUrtle* provides a functionality to visualize the proportional differences in dimensional reduction coordinates. For the visualization with `plot_dimensional_reduction()`, we need a data frame of two coordinates per cell / samples - presumably from a dimensional reduction method like PCA, TSNE or UMAP.

In this example data set, the `tiss` object (from [Sample metadata](#sample-metadata)) contains usable TSNE coordinates:

```{r}
head(tiss@dr$tsne@cell.embeddings, n=5)
```

We can provide this data frame directly to the `reduction_df` parameter of `plot_dimensional_reduction()` function:

```{r, fig.height=6, fig.width=8, fig.align = "center", out.width="80%"}
temp <- plot_dimensional_reduction(dturtle = dturtle, 
                           reduction_df = tiss@dr$tsne@cell.embeddings,
                           plot = "proportions", genes = "Lcn2", plot_scale = "free_y")
grid::grid.draw(temp$Lcn2)
```

By default significant transcripts are highlighted by a red background name. Because of this modification, a `grob` object is returned. If `indicate_significant_tx` is set to `FALSE`, a more common `ggplot2` object is returned.

Besides the actual transcript proportions, it is also possible to display the (log-transformed) expression values of the gene and the single transcripts in the plot.


```{r}
dturtle <- plot_dimensional_reduction(dturtle = dturtle, 
                                 reduction_df = tiss@dr$tsne@cell.embeddings,
                                 plot = "proportions",
                                 savepath = "images", 
                                 add_to_table = "dimensional_reduction",
                                 BPPARAM = biocpar)
```


```{r}
head(dturtle$dtu_table$transcript_view)
head(list.files("./images/"))
```

---

### Visualize DTU table

The `dturtle$dtu_table` is now ready to be visualized as an interactive HTML-table. Please note, that it is optional to add any plots or additional columns to the table. Thus the visualization will work directly after calling `create_dtu_table()`.

The `dtu_table` object looks like this:

```{r}
head(dturtle$dtu_table)
```


Before creating the actual table, we can optionally define column formatter functions, which colour the specified columns. The colouring might help with to quickly dissect the results.

*DTUrtle* come with some pre-defined column formatter functions (for p-values and percentages), other formatter functions from the `formattable` package can also be used. Advanced users might also define their own functions.

We create a named list, linking column names to formatter functions:

```{r}
column_formatter_list <- list(
      "gene_qvalue" = table_pval_tile("white", "orange", digits = 3),
      "minimal_tx_qvalue" = table_pval_tile("white", "orange", digits = 3),
      "number_tx" = formattable::color_tile('white', "lightblue"),
      "number_significant_tx" = formattable::color_tile('white', "lightblue"),
      "max(T cell-luminal epithelial cell of mammary gland)" = table_percentage_bar('lightgreen', "#FF9999", digits=2),
      "max_tx_expr_in_T_cell" = table_percentage_bar('white', "lightblue", color_break = 0, digits=2),
      "max_tx_expr_in_luminal_epithelial_cell_of_mammary_gland" = table_percentage_bar('white', "lightblue", color_break = 0, digits=2),
      "abs_diff_expr_in" = table_percentage_bar('white', "lightblue", color_break = 0, digits=2))

```

This `column_formatter_list` is subsequently provided to `plot_dtu_table()`:

```{r}
plot_dtu_table(dturtle = dturtle, savepath = "my_results.html", 
               column_formatters = column_formatter_list)
```


> <div class="alert alert-info">
>
> <strong>Note:</strong> ️As seen above, the paths to the plots are relative. Please make sure that the saving directory in `plot_dtu_table()` is correctly set and the plots are reachable from that directory with the given path.
>
> <strong>The links in the following example are just for demonstration purposes and do not work!</strong> 
>
> </div>



<style>
.vscroll-plot {
    overflow: auto;
    resize: both;
}
</style>

<div class="vscroll-plot">
```{r, echo=FALSE}
plot_dtu_table(dturtle = dturtle, column_formatters = column_formatter_list, min_page_length=10)
```
</div>

---

## Workflow with Seurat object

As an Seurat object of the data set is already present in the Tabula muris publication, we can directly use this object in some DTUrtle analysis. Additionally, we can create an Seurat object containing both, gene and transcript level quantification data.

### Seurat object and data import

We assume, you have followed this vignette till the [Sample metadata](#sample-metadata) section. The `tiss` Seurat object is still present from 

```{r}
load("../droplet_Mammary_Gland_seurat_tiss.Robj", verbose=TRUE)
tiss
tiss@version
```

We see the `tiss` object is a Seurat v2 object - DTUrtle can only process Seurat v3 or higher objects.

Luckily, there is a Seurat function to convert a v2 object to the v3 style:

```{r}
tiss <- Seurat::UpdateSeuratObject(tiss)
tiss
tiss@version
```

This updated object can now be used as input for the DTUrtle function `combine_to_matrix()`. We assume, we still have the `cts_list` object present from the [initial import](#reading-in-quantification-data).

```{r}
lapply(cts_list, dim)
```

As in the workflow without the Seurat object, we want to combine the two matrices and subset the matrix to cells where we have metadata for (i.e. the cells present in the Seurat object).

We can achieve both tasks by directly supplying the Seurat object to the `combine_to_matrix()`:

```{r}
tiss <- combine_to_matrix(tx_list = cts_list, seurat_obj = tiss, tx2gene = tx2gene, cell_extension_side = "prepend")
```

We supply the list of count matrices per sample (`cts_list`), as well as the Seurat object. When a Seurat object is present, DTUrtle tries to infer the used cellname extensions from the Seurat object - which works in this case as expected and we do not have to provide the cell extensions by our own. 
Optionally, we can also provide the tx2gene when supplying a Seurat object, than the transcript to gene mapping will be added to the metadata of the newly created Seurat Assay.

```{r}
tiss
tiss@active.assay
```

We see, the active assay of the Seurat object changed (to 'dtutx') and that assay contains way more features than before (as these are transcript level counts).

Adding the a transcript level assay to the Seurat object is quite handy for downstream functionality. The tiss object can now be handled as any other Seurat object, but returns transcript-level results by default.


This Seurat object can be used in the downstream DTUrtle pipeline instead of the `cts` object, alternatively we can pull the actual count matrix from the object:

```{r}
seur_cts <- Seurat::GetAssayData(tiss)
dim(seur_cts)
dim(cts)
```

We can see a subtle difference in the number of features here. This is due to the fact, that the original `cts` was created taking all original 8318 cells into account (and filtering all not expressed features) - while the `seur_cts` object was subset to the 4481 we want to use before excluding not expressed features.

This difference has no downstream effect, as not expressed features are also excluded in the `run_drimseq()` filtering step.

As a sanity check, we can see if these two matrices are identical (at least for common features):

```{r}
identical(seur_cts, cts[match(rownames(seur_cts), rownames(cts)),])
```

### Identify cell type specific transcripts

As an example for downstream use of a Seurat object with transcript level information, we can use established Seurat functions to identify cell type specific transcripts. These cell types are annotated in the Seurat object:

```{r}
table(tiss$cell_ontology_class)
```

We can identify cell type specific transcripts via Seurats `FindAllMarkers` functionality. Please note, that this marker identification is based on transcript counts, not proportions - thus it does not render a DTU analysis obsolete. It offers a quick way to identify transcripts, which are almost solely expressed in a single cell type.

```{r}
#set cell types as active ident
Idents(tiss) <- tiss$cell_ontology_class
tiss <- NormalizeData(tiss)
cell_markers <- FindAllMarkers(tiss, only.pos=TRUE)
```


Apparently, we identified quite a lot of transcript as markers:

```{r}
dim(cell_markers)

head(cell_markers, n = 5)
```
We can split the markers by their cell type:
```{r}
table(cell_markers$cluster)
```

We can search for marker transcripts, which were also identified in the DTU analysis (between `T cell` and `luminal epithelial cell of mammary gland`):
```{r}
#select common transcripts
dtu_markers <- cell_markers[cell_markers$gene %in% dturtle$sig_tx,]
table(dtu_markers$cluster)
```

We see many markers, which have also been identified in the DTU analysis, are for the expected cell types (`luminal epithelial cell of mammary gland` and `T cell`). This becomes even more prominent, when we take the total amount of markers per cell type into account:

```{r}
table(dtu_markers$cluster)/table(cell_markers$cluster)
```

We see an over-representation of markers in the expected cell types.

---

Of great interest would be transcript markers of the same gene for different cell types. This would implicate a cell type specific expression of a transcript isoform.

We can identify such markers by first adding the corresponding gene to the marker list, then looking for genes occurring more than once: 


```{r}
dup_markers <- dtu_markers
#add corresponding genes and change naming
dup_markers$tx <- dup_markers$gene
dup_markers$gene <- tx2gene$gene_name[match(dup_markers$tx, tx2gene$transcript_name)]
#sort table by gene names
dup_markers <- dup_markers[order(dup_markers$gene),]

#identify genes occuring more than once
dups <- table(dup_markers$gene)
dups <- dups[dups>1]

#subset to duplicate genes
dup_markers <- dup_markers[dup_markers$gene %in% names(dups),]
nrow(dup_markers)
```

Apparently 969 markers are belonging to genes, which occur more than once. We now can look for genes, where the markers are in our cell types of interest:

```{r}
#identify markers of the same gene, that are in our cell types of interest
interesting_dups <- aggregate(formula = dup_markers$cluster~dup_markers$gene, FUN=function(x){
  ("luminal epithelial cell of mammary gland" %in% x & "T cell" %in% x)
})
interesting_dups <- interesting_dups[interesting_dups$`dup_markers$cluster`==TRUE,]


dup_markers[dup_markers$gene %in% interesting_dups$`dup_markers$gene`,]

```

There are 9 genes, which fulfill our query.

Among them is 'Rps24' (), which expression looks quite promising.

We can again use the DTUrtle visualization function `plot_dimensional_reduction()`, utilizing the already present TSNE dimensional reduction:

```{r, fig.height=6, fig.width=8, fig.align = "center", out.width="80%"}
#pull the TSNE coordinates from the seurat object.
p <- plot_dimensional_reduction(dturtle = dturtle, reduction_df = tiss, reduction_to_use="tsne", genes = "Rps24")
grid::grid.draw(p$Rps24)
```

We see a striking difference for two transcripts: While 'Rps24-210' has a very high expression proportion in 'T cell', 'Rps24-202' seems to be almost specifically expressed in 'luminal epithelial cell of mammary gland'.

To get an overview of 'Rps24' transcript expression of the total data set, we can utilize the Seurat plotting functionality:
```{r, fig.height=4, fig.width=8, fig.align = "center", out.width="80%"}
DimPlot(tiss)
FeaturePlot(tiss, features = c("Rps24-202", "Rps24-210"), order = TRUE)
```

We see, that the isoforms are not specific for a single cell type, but for multiple. Still we see a striking difference, with a very pronounced expression of 'Rps24-210' in 'T cell', 'B cell', 'macrophages' and a small subcluster of 'stromal cells'.


---

For later use we can save the final DTUrtle object to disk:

```{r}
saveRDS(dturtle, "./dturtle_res.RDS")
saveRDS(tiss, "./tiss.RDS")
```

---

## Session info

Computation time for this vignette:

```{r, echo=FALSE}
Sys.time()-start_time
```

---

```{r sessionInfo, echo=FALSE}
sessionInfo()
```

